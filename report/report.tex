% Preamble
% =============================================================================

% Class of the document.
\documentclass[12pt,a4paper]{article}
% article : short article.
% report  : mid-length report.
% book    : book or thesis redaction.

% Paragraph skip length (default to 0).
\setlength{\parskip}{1ex}

% Packages
% =============================================================================

% Encoding
% -----------------------------------------------------------------------------

% Babel.
\usepackage[french]{babel}
% FontEnc.
\usepackage[T1]{fontenc}
% InputEnc.
\usepackage[utf8]{inputenc}

% Text
% -----------------------------------------------------------------------------

% Acronym.
\usepackage{acronym}
% CsQuote.
\usepackage[style=french,french=guillemets]{csquotes}
% Enumerate.
\usepackage{enumerate}
% HyperRef.
\usepackage[hyperfootnotes=false,hidelinks]{hyperref}
% URL.
\usepackage{url}

% Algorithms
% -----------------------------------------------------------------------------

% Algorithm2E.
\usepackage[french,onelanguage,linesnumbered,ruled,vlined,commentsnumbered]{algorithm2e}

% Source code
% -----------------------------------------------------------------------------

% Listings.
\usepackage{listings}
% Minted.
\usepackage{minted}
% Caption.
\usepackage{caption}
\newenvironment{code}{\captionsetup{type=listing}}{}

% Figures
% -----------------------------------------------------------------------------

% GraphicX.
\usepackage{graphicx}
% SVG.
\usepackage{svg}
% WrapFig.
\usepackage{wrapfig}

% Charts
% -----------------------------------------------------------------------------

% PGFPLots
\usepackage{pgfplots}
\pgfplotsset{compat=1.16}
\usepgfplotslibrary{units}

% Mathematics
% -----------------------------------------------------------------------------

% AmsFonts.
\usepackage{amsfonts}
% AmsMath.
\usepackage{amsmath}
% AmsText.
\usepackage{amstext}
% AmsThm.
\usepackage{amsthm}
\newtheorem{prr}{Propriété}
\newtheorem{pro}{Proposition}
\newtheorem{thm}{Théorème}
\newtheorem{lem}{Lemme}
% NumPrint.
\usepackage{numprint}

% Physics
% -----------------------------------------------------------------------------

% Physics.
\usepackage{physics}

% Presentation
% -----------------------------------------------------------------------------

% XColor.
\usepackage{xcolor}

% References
% -----------------------------------------------------------------------------

% CleveRef.
\usepackage{cleveref}

% Structure.
% -----------------------------------------------------------------------------

% Geometry.
\usepackage{geometry}
% PDFLScape.
\usepackage{pdflscape}
% MultiCol.
\usepackage{multicol}
% TitleSec.
\usepackage{titlesec}
\newcommand{\sectionbreak}{\clearpage} % Use a page break before new sections.
% VMargin.
\usepackage{vmargin}
% FootMisc.
\usepackage[bottom]{footmisc}

% Symbols
% -----------------------------------------------------------------------------

% SIUnitX.
\usepackage{siunitx}

% Table
% -----------------------------------------------------------------------------

% Array.
\usepackage{array}
% BookTabs.
\usepackage{booktabs}
% CSVSimple.
\usepackage{csvsimple}

% Document
% =============================================================================

\begin{document}

\title{Base de données avec Oracle DBA sur les championnats de moto}
\author{Pierre AYOUB et Maël ROUXEL}

\maketitle

\begin{figure}[b]
    \centering
    \includegraphics[scale=0.3]{figures/isty.jpg}
\end{figure}

\newpage
\begin{abstract}

Oracle Database est un système de gestion de base de données relationnelle
(SGBD) utilisé dans le monde entier. Très répandu en entreprise, tant pour
ses performances que sa fiabilité, nous utilisons ce SGBD afin de créer une
base de données et d’y effectuer des tâches d’administration. Plusieurs
possibilités offertes par Oracle DBA seront explorées dans ce projet.

\end{abstract}

\tableofcontents

\section{Introduction}
\label{sec.intro}

Notre projet modélise une base de données concernant les championnats de moto.
L’objectif de cette base est de stocker des informations non pas sur une seule
saison de course, mais sur plusieurs saisons. De plus, on pourra stocker au sein
d’une même base plusieurs championnats différents. Beaucoup d'informations
techniques sont retenues concernant les motos et les résultats des pilotes sur
chaque course, ce qui permettra d’obtenir des statistiques poussées et
diversifiées. La base de données possède quelques contraintes, listées
ci-dessous (pour les moins évidentes) :

\begin{itemize}
    \item Une saison d'un championnat dure une année.

    \item Par saison, un pilote peut participer à plusieurs championnats.

    \item Pour un championnat donné, un pilote ne peut faire partie que d'une
        team. Dans le cas où le pilote participe à plus d'un championnat sur une
        saison, alors il peut faire partie de plusieurs teams différentes
        concourantes sur différents championnats.

    \item Pour un championnat donné et une team donné, un pilote ne peut
        utiliser qu'une moto. Dans le cas où le pilote participe à plus d'un
        championnat différent sur une saison, alors il peut utiliser plusieurs
        motos différentes sur les différents championnats.

    \item Chaque pilote doit être sous contrat pour pouvoir courir dans un
        championnat. Un contrat est un CDD liant un pilote, un modèle de moto
        et une team pendant un temps donné (généralement, quelques années).

    \item La participation d’un pilote à une course correspond à une relation
        entre ladite course et le contrat d’un pilote.
\end{itemize}

\section{Mise en place de la base de données}
\label{sec.reference}

Dans cette section, nous vous présenterons la mise en place de la base de
données. Pour la majorité du travail ci-dessous, cela concerne le langage de
requête SQL ou l’utilisation de l’utilitaire de chargement de données Oracle SQL
Loader.

\subsection{Schéma de la base de données}
\label{sub.scheme}

La création du schéma de la base de données consiste à créer les tables en
spécifiant les attributs, leurs types, et leurs contraintes d'intégrité
basiques telles que les clés primaires et étrangères, ainsi que les contraintes
check.

\begin{code}
    \begin{minted}[linenos,numbersep=5pt,frame=lines,framesep=2mm,breaklines=true]{SQL}
    -- Création des tables.

    -- 1. Marques de moto.
    CREATE TABLE Marque
    (
        Nom         VARCHAR(32) NOT NULL,
        Annee       DATE,       -- CHECK with a trigger.
        Nationalite CHAR(2),    -- CHECK with a trigger.
        PRIMARY KEY (Nom)
    );

    -- 2. Teams concourrant aux championnats.
    CREATE TABLE Team
    (
        Nom    VARCHAR(32) NOT NULL,
        Marque VARCHAR(32) NOT NULL,
        PRIMARY KEY (nom)
    );

    -- 3. Modèles de moto.
    CREATE TABLE Modele_moto
    (
        Marque      VARCHAR(32) NOT NULL,
        Nom         VARCHAR(32) NOT NULL,
        Annee       DATE        NOT NULL, -- CHECK with a trigger.
        Cylindree   FLOAT       CHECK (Cylindree > 20 AND Cylindree < 2000),
        Couple      FLOAT       CHECK (Couple > 1     AND Couple < 20),
        Puissance   FLOAT       CHECK (Puissance > 1  AND Puissance < 500),
        Poids       FLOAT       CHECK (Poids > 30     AND Poids < 500),
        Prix        NUMBER(6)   CHECK (Prix > 100 AND Prix < 500000),
        Genre       VARCHAR(40) NOT NULL CHECK (Genre IN ('Sportive', 'Cafe Racer')),
        PRIMARY KEY (nom, annee)
    );

    -- 4. Pilotes appartenant aux teams.
    CREATE TABLE Pilote
    (
        Id          NUMBER(4)   NOT NULL, -- CHECK with a trigger.
        Nom         VARCHAR(32) NOT NULL,
        Prenom      VARCHAR(32) NOT NULL,
        Age         NUMBER(3)   CHECK (Age BETWEEN 10 and 100),
        Nationalite CHAR(2),    -- CHECK with a trigger.
        Sexe        CHAR(1)     CHECK (Sexe IN (NULL, 'H', 'F')),
        Numero      NUMBER(2)   CHECK (Numero BETWEEN 0 and 99),
        PRIMARY KEY (id)
    );

    -- 5. Championnats existants.
    CREATE TABLE Championnat
    (
        Nom         VARCHAR(32) NOT NULL,
        Annee       DATE        NOT NULL,   -- CHECK with a trigger.
        PRIMARY KEY (Nom, Annee)
    );

    -- 6. Circuits sur lesquels les courses se déroulent.
    CREATE TABLE Circuit
    (
        Nom      VARCHAR(32) NOT NULL,
        Pays     CHAR(2)     NOT NULL,  -- CHECK with a trigger.
        Longueur FLOAT       CHECK (Longueur BETWEEN 0.5 AND 20),
        PRIMARY KEY (Nom)
    );

    -- 7. Courses appartenants aux championnats.
    CREATE TABLE Course_vitesse
    (
        Championnat VARCHAR(32) NOT NULL,
        Annee       DATE        NOT NULL,
        Date_course DATE        NOT NULL, -- CHECK with trigger.
        Circuit     VARCHAR(32) NOT NULL,
        Nb_tours    NUMBER(2)   CHECK (Nb_tours BETWEEN 1 AND 30),
        Duree       FLOAT       CHECK (Duree BETWEEN 1 AND 100),
        PRIMARY KEY (Championnat, Date_course)
    );

    -- 8. Participation d'un pilote à une course.
    CREATE TABLE Participe (
        Id_pilote       INT         NOT NULL,
        Championnat     VARCHAR(32) NOT NULL,
        Date_course     DATE        NOT NULL,
        Modele_moto     VARCHAR(32) NOT NULL,
        Annee_moto      DATE        NOT NULL,
        Classement      NUMBER(2)   CHECK (Classement BETWEEN 0 AND 30),
        Points_gagnes   NUMBER(2)   CHECK (Points_gagnes BETWEEN 0 AND 25),
        Vitesse_moy     FLOAT       CHECK (Vitesse_moy BETWEEN 0 AND 300),
        Meilleur_tour   FLOAT       CHECK (Meilleur_tour BETWEEN 0 AND 400),
        PRIMARY KEY (Id_pilote, Championnat, Date_course, Modele_moto, Annee_moto)
    );

    -- 9. Contrats liants un pilote, une équipe et un modèle de moto.
    CREATE TABLE Contrat (
        Id_pilote   NUMBER(4)   NOT NULL,
        Moto_modele VARCHAR(32) NOT NULL,
        Moto_annee  DATE        NOT NULL,
        Team_nom    VARCHAR(32) NOT NULL,
        Annee_debut DATE        NOT NULL,
        Annee_fin   DATE        NOT NULL,
        PRIMARY KEY (Id_pilote, Moto_modele, Moto_annee, Team_nom, Annee_debut)
    );

    -- Configure les clés étrangères.

    ALTER TABLE Team
        ADD FOREIGN KEY (Marque) REFERENCES Marque (Nom);

    ALTER TABLE Modele_moto
        ADD FOREIGN KEY (Marque) REFERENCES Marque (Nom);

    -- Désactivé car on utilise un trigger pour ces clés, conformément à la consigne.
    --  ALTER TABLE Course_vitesse
        --  ADD FOREIGN KEY (Championnat, Annee) REFERENCES Championnat (Nom, Annee);
    ALTER TABLE Course_vitesse
        ADD FOREIGN KEY (Circuit) REFERENCES Circuit (Nom);

    ALTER TABLE Participe
        ADD FOREIGN KEY (Id_pilote) REFERENCES Pilote (Id);
    ALTER TABLE Participe
        ADD FOREIGN KEY (Championnat, Date_course) REFERENCES Course_vitesse (Championnat, Date_course);
    ALTER TABLE Participe
        ADD FOREIGN KEY (Modele_moto, Annee_moto) REFERENCES Modele_moto (Nom, Annee);

    ALTER TABLE Contrat
        ADD FOREIGN KEY (Id_pilote) REFERENCES Pilote (Id);
    ALTER TABLE Contrat
        ADD FOREIGN KEY (Moto_modele, Moto_annee) REFERENCES Modele_moto (Nom, Annee);
    ALTER TABLE Contrat
        ADD FOREIGN KEY (Team_nom) REFERENCES Team (Nom);
    \end{minted}
    \caption{Code SQL permettant de mettre en place la base de données}
    \label{lst.create}
\end{code}

\subsection{Jeu de données}
\label{sub.data}

Pour le chargement du jeu de données, nous avons utilisé l'utilitaire spécialisé
Oracle SQL Loader. Du fait que cela ne serait pas pertinent d’inclure
l’intégralité du jeu de données dans le rapport, nous allons uniquement vous
présenter un exemple d’un fichier de données CSV et d’un fichier de contrôle
CTL. Le fichier CSV contient les valeurs des données allant s’intégrer dans les
tables crées précédemment, tandis que le fichier CTL contient des informations
sur la manière dont les données doivent être chargées depuis le fichier CSV. Par
exemple, des précisions sur le type de données, telles que le format de la date.

\begin{code}
    \begin{minted}[linenos,numbersep=5pt,frame=lines,framesep=2mm,breaklines=true]{SQL}
    LOAD DATA
    INFILE './Data/Participe.csv'
    TRUNCATE
    INTO TABLE Participe
    FIELDS TERMINATED BY ';'
    TRAILING NULLCOLS
    (
        Id_pilote,
        Championnat,
        Date_course DATE "YYYY-MM-DD",
        Modele_moto,
        Annee_moto DATE "YYYY",
        Classement,
        Points_gagnes,
        Vitesse_moy,
        Meilleur_tour
    )
    \end{minted}
    \caption{Code SQL Loader permettant de charger des données dans une table}
    \label{lst.loadctl}
\end{code}

\begin{code}
    \begin{minted}[linenos,numbersep=5pt,frame=lines,framesep=2mm,breaklines=true]{SQL}
    Id_pilote;Championnat;Date_course;Modele_moto;Annee_moto; Classement;Points_gagnes;Vitesse_moy;Meilleur_tour
    1;MotoGP;2016-03-20;M1;2016;1;25;167.1;114.543
    0;MotoGP;2016-03-20;Desmosedici GP;2013;2;20;167.0;;
    7;MotoGP;2016-03-20;RC213V;2012;3;16;167.0;;
    4;MotoGP;2016-03-20;M1;2016;4;13;167.0;;
    8;MotoGP;2016-03-20;RC213V;2012;5;11;166.2;;
    5;MotoGP;2016-03-20;GSX-RR;2014;6;10;166.1;;
    11;MotoGP;2016-03-20;RC213V-RS;2015;14;2;164.4;;
    6;MotoGP;2016-03-20;RC213V;2012;0;0;165.0;;
    10;MotoGP;2016-03-20;GSX-RR;2014;18;0;;;
    4;MotoGP;2016-04-24;M1;2016;1;25;157.5;100.090
    [...]
    13;Superbike;2015-02-22;GSX-R1000;2014;9;7;;;92.690
    14;Superbike;2015-02-22;ZX-10R;2015;6;10;;;92.016
    \end{minted}
    \caption{Fichier CSV contenant des données à charger (extrait)}
    \label{lst.loadcsv}
\end{code}

De plus, nous avons utilisé une séquence (initialisée à partir du nombre maximum
déjà inséré dans la base de données) afin de générer des entiers naturels
consécutifs en tant qu'identifiant pour nos pilotes :

\begin{code}
    \begin{minted}[linenos,numbersep=5pt,frame=lines,framesep=2mm,breaklines=true]{SQL}
    -- Création des séquences.

    -- 1. Création et configuration de la séquence des IDs des pilotes.
    DECLARE
        max_pilote_id NUMBER := 0;
    BEGIN
        SELECT MAX(Id) INTO max_pilote_id FROM Pilote;
        EXECUTE IMMEDIATE 'CREATE SEQUENCE PiloteID INCREMENT BY 1 START WITH ' || (max_pilote_id + 1);
    END;
    /
    CREATE OR REPLACE TRIGGER pilote_set_id BEFORE INSERT ON Pilote FOR EACH ROW
    DECLARE
    BEGIN
        :NEW.Id := PiloteID.NextVal;
    END;
    /
    \end{minted}
    \caption{Code SQL permettant d'initialiser et d'utiliser une séquence}
    \label{lst.seq}
\end{code}

\subsection{Manipulation des données par requêtes SQL}
\label{sub.req}

Afin de pouvoir interagir avec la base de données, nous avons imaginé et élaboré
20 requêtes qui pourrait être émises dans une situation vraisemblable (pas
forcément commune cela dit) tout en tâchant de faire varier les fonctionnalités
utilisées. Certaines de ces requêtes pourraient correspondre à des demandes
simples de la part d'un utilisateur consultant un site web ayant enregistré les
données, mais d'autres requêtes correspondent plutôt à des actions uniques qui
seraient demandées dans une situation particulière.

Voici donc la liste de ces 20 requêtes :
\begin{code}
    \begin{minted}[linenos,numbersep=5pt,frame=lines,framesep=2mm,breaklines=true]{SQL}
    --1. On voudrait connaître la liste des championnats différents pour chaque année.
    
    SELECT Cv.championnat, EXTRACT(YEAR FROM Cv.date_course) AS Annee
    FROM Course_vitesse Cv
    GROUP BY Cv.championnat, EXTRACT(YEAR FROM Cv.date_course);
    
    --2. On voudrait connaître la liste des pilotes et de leur score total au championnat MotoGP de 2016, autrement dit, le classement de ce championnat

    SELECT Pi.prenom, Pi.nom, Pi.numero, SUM(Pa.points_gagnes) AS Nombre_total_de_point
    FROM Pilote Pi, Participe Pa
    WHERE Pa.id_pilote = Pi.id
        AND Pa.championnat LIKE 'MotoGP'
        AND EXTRACT(YEAR FROM Pa.date_course) LIKE 2016
    GROUP BY Pi.prenom, Pi.nom, Pi.numero
    ORDER BY SUM(Pa.points_gagnes) DESC;
    
    -- 3.  Dans le même genre, on voudrait connaître le nombre de points total gagnés par les pilotes dans tous les championnats confondus, afin de faire un classement général
    
    SELECT P.Nom, P.Prenom, SUM(PA.points_gagnes) as total_point
    FROM Pilote P,Participe PA
    WHERE P.Id = PA.Id_pilote
    GROUP BY P.Nom,P.Prenom
    ORDER BY SUM(PA.points_gagnes) DESC;
    
    --4. On veut maintenant connaître le classement des équipes au MotoGP de 2016, en additionnant les points remportés par chaque pilote courant pour cette équipe. On va ainsi faire une somme des résultats de la requête n°2.

    SELECT C.Team_nom, SUM(Nombre_total_de_point_pilote) AS Nombre_total_de_point
    FROM Contrat C, (
        SELECT Pi.id, SUM(Pa.points_gagnes) AS Nombre_total_de_point_pilote
        FROM Pilote Pi, Participe Pa
        WHERE Pa.id_pilote = Pi.id
            AND Pa.championnat LIKE 'MotoGP'
            AND EXTRACT(YEAR FROM Pa.date_course) LIKE 2016
        GROUP BY Pi.id
    ) score_pilote
    WHERE score_pilote.id = C.id_pilote
        AND EXTRACT(YEAR FROM C.annee_debut) <= 2016
        AND (
            EXTRACT(YEAR FROM C.annee_fin) >= 2016
            OR C.annee_fin IS NULL
        )
    GROUP BY C.team_nom
    ORDER BY SUM(Nombre_total_de_point_pilote) DESC;
    
    --5. Et enfin, on veut connaître le classement des marques pour le MotoGP. Étant donné que chaque équipe est affiliée à une marque, cela signifie qu'on va faire une somme des résultats de la requête n°4.

    SELECT T.marque, SUM(Nombre_total_de_point_team) AS Nombre_total_de_point
    FROM Team T, (
        SELECT C.Team_nom, SUM(Nombre_total_de_point_pilote) AS Nombre_total_de_point_team
        FROM Contrat C, (
            SELECT Pi.id, SUM(Pa.points_gagnes) AS Nombre_total_de_point_pilote
            FROM Pilote Pi, Participe Pa
            WHERE Pa.id_pilote = Pi.id
                AND Pa.championnat LIKE 'MotoGP'
                AND EXTRACT(YEAR FROM Pa.date_course ) LIKE 2016
            GROUP BY Pi.id
        ) score_pilote
        WHERE score_pilote.id = C.id_pilote
            AND EXTRACT(YEAR FROM C.annee_debut) <= 2016
            AND (
                EXTRACT(YEAR FROM C.annee_fin) >= 2016
                OR C.annee_fin IS NULL
            )
        GROUP BY C.team_nom
    ) score_team
    WHERE T.nom = score_team.team_nom
    GROUP BY T.marque
    ORDER BY Nombre_total_de_point DESC;
    
    --6. Intéressés par les performances des pilotes espagnols, on désire connaître la moyenne de points obtenus par les pilotes espagnols pour chaque course du MotoGP.

    SELECT Pi.prenom, Pi.nom, Pi.numero, AVG(Pa.points_gagnes) AS Moyenne
    FROM Pilote Pi, Participe Pa
    WHERE Pa.id_pilote = Pi.id
        AND Pa.championnat LIKE 'MotoGP'
        AND Pi.nationalite LIKE 'ES'
    GROUP BY Pi.prenom, Pi.nom, Pi.numero;
    
    --7. On voudrait savoir combien de pilotes de moins 30 ans sont actuellement sous contrat avec une moto de type "sportive".

    SELECT COUNT(*) as nb_pilotes_moins_30_ans_moto_sportive
    FROM Pilote P, Contrat C, Modele_moto M
    WHERE P.Id = C.Id_pilote
        AND C.Moto_modele = M.Nom
        AND C.Moto_annee = M.Annee
        AND M.Genre = 'Sportive'
        AND P.Age <= 30
        AND EXTRACT(YEAR FROM C.annee_fin) >= 2019;
        
    --8. Curieux de connaître les pilotes les moins performants, on veut obtenir la liste des pilotes n'ayant jamais participé à une course, ainsi que la liste des pilotes n'ayant jamais remporté une course.

    SELECT Pi.prenom, Pi.nom, 0 AS Nombre_victoire
    FROM Pilote Pi
    WHERE Pi.id NOT IN (
        SELECT Pa.id_pilote
        FROM Participe Pa
    )
    UNION
    SELECT Pi.prenom, Pi.nom, COUNT(*) AS Nombre_victoire
    FROM Pilote Pi, Participe Pa
    WHERE Pi.id = Pa.id_pilote
        AND Pa.classement = 1
    GROUP BY Pi.prenom, Pi.nom
    HAVING COUNT(*) = 0;   
    
    --9. Une marque voudrait obtenir des contrats auprès de pilotes, et pour cela elle désire développer un modèle de moto qui s'inspire des modèles ayant été les plus populaires. Il va alors demander la liste classée des modèles de motos ayant été utilisés plus de six fois lors de courses (pas forcément la même).

    SELECT Modele_moto, EXTRACT(YEAR FROM Annee_moto) as Annee, count(*) as Participations
    FROM Participe
    GROUP BY Modele_moto, Annee_moto
    HAVING count(*) >= 6
    ORDER BY count(*) DESC;
    
    -- 10. Une nouvelle loi a décrétée par l'organisation des courses de moto: tous les contrats terminant cette année et ayant une durée inférieure à 3 ans seront prolongés jusqu'en 2021. On définit une requête qui répond à cette demande.
    
    UPDATE Contrat 
    SET annee_fin = TO_DATE('2021-12-31', 'YYYY-MM-DD')
    WHERE EXTRACT(YEAR FROM annee_fin) = 2019
        AND EXTRACT(YEAR FROM annee_fin) - EXTRACT(YEAR FROM annee_debut) < 3;
        
    -- 11. Suite au Brexit, les marques britanniques ont décidé d'augmenter de 10% le prix de tous leurs modèles de moto.

    UPDATE Modele_moto
    SET Prix = Prix * 1.1
    WHERE Marque = (SELECT Nom FROM Marque M 
                    WHERE Marque = M.nom
                    AND Nationalite = 'GB');

    -- 12. On désire faire une étude de stratégie des marques vis à vis de la puissance de leur modèle. On demande une liste donnant le modèle le plus puissant de chaque marque ayant été utilisé au moins une fois, et on donne le meilleur temps moyen obtenu avec ce modèle.

    SELECT MMA.Marque, MMA.Nom, MMA.Annee, MMA.Puissance, P.Vitesse_moy
    FROM Modele_moto MMA, Participe P
    WHERE Puissance = (SELECT MAX(Puissance) 
                        FROM Modele_moto MMB 
                        WHERE MMB.Marque = MMA.Marque)
        AND P.Vitesse_moy = (SELECT MAX(Vitesse_moy)
                            FROM Participe PB 
                            WHERE PB.Modele_moto = P.Modele_moto
                            AND PB.Annee_moto = P.Annee_moto)
        AND MMA.Nom = P.Modele_moto
        AND MMA.Annee = P.Annee_moto;
    
    -- 13. Suite à un scandale ayant éclaté après la révélation de pots au vin parmi les pilotes britanniques lors du championnat Superbike de 2015, l'organisation a décidé de supprimer de la base de données toutes les participations de ces pilotes lors de ce championnat.

    DELETE FROM Participe
    WHERE Id_pilote = (SELECT Id FROM Pilote P
                        WHERE Nationalite = 'GB'
                        AND Id_pilote = P.Id)
    AND Championnat = 'Superbike'
    AND EXTRACT(YEAR FROM Date_course) = 2015;
    
    -- 14. Suite à une nouvelle législation espagnole, les motos de type Cafe Racer de plus de 200kg sont interdites sur les circuits espagnols. Le gouvernement a fait pression sur l'organisation pour qu'elle supprime également toutes les participations passées considérées comme maintenant interdites.
    
    DELETE FROM Participe P
    WHERE P.Modele_moto = (SELECT MM.Nom FROM Modele_moto MM
                        WHERE Genre = 'Cafe Racer'
                            AND Poids >= 200
                            AND MM.nom = P.Modele_moto
                            AND MM.annee = P.annee_moto)
    AND Date_course = (SELECT Date_course FROM Course_vitesse CVT
                WHERE CVT.Date_course = P.Date_course
                            AND Circuit = (SELECT Nom FROM circuit
                                            WHERE Pays = 'ES'));
                                            
    -- 15. A l'occasion du salon de la moto, les marques ont décidé de sur-renchérir un peu en augmentant de 1000€ le prix de tous leurs modèles ayant déjà remporté une première place lors d'une course.

    UPDATE Modele_moto
    SET Prix = Prix + 1000
    WHERE (Nom,Annee) = (SELECT Modele_moto,Annee_moto FROM Participe
                        WHERE Classement = 1
                            AND Participe.Modele_moto = Modele_moto.Nom
                            AND Participe.Annee_moto = Modele_moto.Annee
                            GROUP BY Modele_moto,Annee_moto);
                            
    -- 16. L'organisation des championnats a décrété que dû aux conditions de température difficiles en Australie, les comptes de points sont rééquilibrés en augmentant d'un point tous les scores obtenus lors de courses sur un circuit Australien.

    UPDATE Participe P
    SET points_gagnes = points_gagnes + 1
    WHERE date_course = (SELECT date_course as DCB FROM Course_vitesse CV
                        WHERE CV.Date_course = P.date_course
                            AND CV.Circuit = ( SELECT Nom from Circuit C
                            WHERE C.Nom = CV.Circuit
                                                    AND C.Pays = 'AU'));
    
    -- 17. On désire savoir quels sont les modèles de motos ayant été le plus souvent la cible d'un contrat. On dresse le compte du nombre de contrats effectués pour chaque modèle de moto.

    SELECT Moto_modele, EXTRACT(YEAR FROM Moto_annee) as Annee, count(*) AS Nb_of_contracts
    FROM Contrat
    GROUP BY Moto_modele,Moto_annee
    ORDER BY count(*) DESC;
    
    -- 18. On voudrait voir quel pilote est le plus efficace sur quel circuits. On dresse le classements du plus grand nombre de victoire par pilote pour chaque circuit.

    SELECT C.Nom , P.Nom, P.Prenom, COUNT(*) as nb_win
    FROM Circuit C, Pilote P, Participe PA
    WHERE PA.Id_pilote = P.Id
        AND PA.Date_course = (SELECT CV.Date_course FROM Course_vitesse CV
                                WHERE CV.Circuit = C.Nom
                                AND PA.Date_course = CV.date_course)
                                AND PA.Classement = 1
    GROUP BY C.Nom , P.Nom, P.Prenom
    ORDER BY count(*);
        
    --19. Pour la nouvelle saison, on met à jour l'âge de tous les pilotes toujours actifs (encore sous contrats) en l'augmentant de 1 an.

    UPDATE Pilote P
    SET Age = Age + 1
    WHERE Id = (SELECT Id_pilote FROM contrat C
            WHERE P.Id = C.Id_pilote
                 AND EXTRACT(YEAR FROM annee_fin) >= 2019);
                
    -- 20. Une équipe désire connaître la liste des pilotes les plus actifs récemment en vue de leur proposer des futurs contrats. On fait une requête donnant la liste des pilotes encore sous contrat, avec la date de leur dernière course, et la date d'expiration de leur contrat actuel.

    SELECT P.Nom,P.prenom,PA.Date_course, EXTRACT(YEAR FROM C.annee_fin) as fin_contrat
    FROM Pilote P, Participe PA, Contrat C
    WHERE P.Id = PA.id_pilote
        AND P.Id = C.id_pilote
        AND EXTRACT(YEAR FROM C.annee_fin) >= 2019
        AND PA.Date_course = (SELECT MAX(Date_course) FROM Participe PAB
                    WHERE PA.Date_course = PAB.Date_course
                    AND PA.id_pilote = PAB.id_pilote)
    GROUP BY P.Nom,P.prenom,PA.Date_course,EXTRACT(YEAR FROM C.annee_fin);
    \end{minted}
    \caption{Code SQL permettant d'exécuter les requêtes sur la base de données}
    \label{lst.request}
\end{code}

\subsection{Vues}
\label{sub.views}

Notre base de données contient quelques vues permettant de visualiser des scores
et des statistiques calculées à partir de notre jeu de données. De tels vues se
destineraient à être incluses dans un site ou service web permettant de consulter
des statistiques sur les championnats de moto, avec des paramètres dynamiques
tel que, par exemple, l'année des scores pour ledit championnat.

\begin{code}
    \begin{minted}[linenos,numbersep=5pt,frame=lines,framesep=2mm,breaklines=true]{SQL}
    -- Création des vues.

    -- 1. Liste des scores des pilotes au MotoGP de 2016.
    CREATE VIEW MotoGP_2016_Score_pilotes AS
        SELECT Pi.Id, Pi.Numero, Pi.Nom, Pi.Prenom, SUM(Pa.Points_gagnes) AS Nombre_total_de_point
        FROM Participe Pa, Pilote Pi
        WHERE Pa.Id_pilote = Pi.Id
            AND Pa.Championnat LIKE 'MotoGP'
            AND TO_CHAR(Pa.Date_course, 'YYYY') LIKE '2016'
        GROUP BY Pi.Id, Pi.Numero, Pi.Nom, Pi.Prenom
        ORDER BY Nombre_total_de_point DESC
        WITH READ ONLY;
    GRANT SELECT ON MotoGP_2016_Score_pilotes to PUBLIC;

    -- 2. Liste des scores des teams au MotoGP de 2016.
    CREATE VIEW MotoGP_2016_Score_teams AS
        SELECT C.Team_nom, SUM(Nombre_total_de_point) AS Nombre_total_de_point
        FROM Contrat C, MotoGP_2016_Score_pilotes S
        WHERE S.Id = C.Id_pilote
            AND TO_DATE(2016, 'YYYY') BETWEEN C.Annee_debut AND C.Annee_fin
        GROUP BY C.Team_nom
        ORDER BY Nombre_total_de_point DESC
        WITH READ ONLY;
    GRANT SELECT ON MotoGP_2016_Score_teams to PUBLIC;

    -- 3. Liste des scores des constructeurs au MotoGP de 2016.
    CREATE VIEW MotoGP_2016_Score_construc AS
        SELECT T.Marque, SUM(Nombre_total_de_point) AS Nombre_total_de_point
        FROM Team T, MotoGP_2016_Score_teams S
        WHERE T.Nom = S.Team_nom
        GROUP BY T.Marque
        ORDER BY Nombre_total_de_point DESC
        WITH READ ONLY;
    GRANT SELECT ON MotoGP_2016_Score_construc to PUBLIC;

    -- 4. Statistiques diverses sur les pilotes du MotoGP.
    CREATE VIEW MotoGP_Pilote_stat AS
        SELECT Pi.Numero, Pi.Nom, Pi.Prenom, Pi.Age, Pi.Nationalite, Pi.Sexe,
            SUM(Pa.Points_gagnes) AS Total_de_points_gagnes,
            MIN(Pa.Classement)    AS Meilleur_classement,
            MAX(Pa.Vitesse_moy)   AS Vitesse_moyenne,
            MIN(Pa.Meilleur_tour) AS Meilleur_tour
        FROM Pilote Pi, Participe Pa
        WHERE Pa.Id_pilote = Pi.Id
            AND Pa.Championnat LIKE 'MotoGP'
        GROUP BY Pi.Numero, Pi.Nom, Pi.Prenom, Pi.Age, Pi.Nationalite, Pi.Sexe
        WITH READ ONLY;
    GRANT SELECT ON MotoGP_Pilote_stat to PUBLIC;

    -- 5. Nombre de victoire des pilotes au MotoGP.
    CREATE VIEW MotoGP_Pilote_win AS
        SELECT Pi.Numero, Pi.Nom, Pi.Prenom, COUNT(*) AS Nombre_de_victoire
        FROM Pilote Pi, Participe Pa
        WHERE Pa.Id_pilote = Pi.Id
            AND Pa.Championnat LIKE 'MotoGP'
            AND Pa.Classement = 1
        GROUP BY Pi.Numero, Pi.Nom, Pi.Prenom
        ORDER BY Nombre_de_victoire DESC
        WITH READ ONLY;
    GRANT SELECT ON MotoGP_Pilote_win to PUBLIC;
    \end{minted}
    \caption{Code SQL permettant de créer les vues de la base de données}
    \label{lst.create}
\end{code}

\section{SQL Avancé}
\label{sec.reference}

Cette deuxième section nous amènera à utiliser des fonctionnalités avancées
d’Oracle DBA et de PL/SQL. Nous étudierons tout d’abord quelques triggers, puis
opérerons à la récupération de méta-données afin d’obtenir des informations sur
notre base de données, enfin nous effectuerons une rapide analyse de requête
SQL.

\subsection{Triggers}
\label{sub.trig}

Les triggers sont utilisés, dans notre projet, afin d'implémenter des
contraintes d'intégrité. Pour la plupart des triggers, ces contraintes ne
peuvent être exprimées avec des clauses CHECK du fait qu’il faut  récupérer les
valeurs de certains tuples d’une autre table et qu’il est nécessaire d’avoir un
contrôle de flux en fonction des résultats. Pour un des triggers ci-dessous,
nous avons ré-implémenté le fonctionnement des clés étrangères, comme demandé
dans le sujet.

\begin{code}
    \begin{minted}[linenos,numbersep=5pt,frame=lines,framesep=2mm,breaklines=true]{SQL}
    -- Création des procédures.

    -- 1. Vérifie qu'une date est inférieure à la date du jour. Nécéssite un
    -- trigger/une procédure pour utiliser SYSDATE.
    CREATE OR REPLACE PROCEDURE date_inferior_to_current_time (new_date IN DATE) IS
    BEGIN
        IF new_date > SYSDATE THEN
            RAISE_APPLICATION_ERROR(-20001, 'Insertion cannot be done because the date is greater than today !');
        END IF;
    END;
    /

    -- 2. Vérifie qu'une nationalité est correct. On pourrait utiliser un CHECK, mais
    -- il faudrait copier-coller les valeurs de nationalités à la main, alors que
    -- l'on peux les regrouper dans une procédure.
    CREATE OR REPLACE PROCEDURE check_nationalite (nat IN CHAR) IS
    BEGIN
        IF (nat NOT IN ('FR', 'GB', 'US', 'IT', 'ES', 'JP', 'CH', 'DE', 'AU', 'QT', 'PB')) THEN
            RAISE_APPLICATION_ERROR(-20001, 'Insertion cannot be done because the nationality is incorrect !');
        END IF;
    END;
    /

    -- Création des triggers.

    -- 1. Vérifie l'année de création et la nationalité d'une marque.
    CREATE OR REPLACE TRIGGER marque_check BEFORE INSERT OR UPDATE ON Marque FOR EACH ROW
    BEGIN
        date_inferior_to_current_time(:new.Annee);
        check_nationalite(:new.Nationalite);
    END;
    /

    -- 2. Vérifie l'année d'un modèle de moto.
    CREATE OR REPLACE TRIGGER modele_moto_check BEFORE INSERT OR UPDATE ON Modele_moto FOR EACH ROW
    BEGIN
        date_inferior_to_current_time(:new.Annee);
    END;
    /

    -- 3. Vérifie la nationalité d'un pilote.
    CREATE OR REPLACE TRIGGER pilote_check BEFORE INSERT OR UPDATE ON Pilote FOR EACH ROW
    DECLARE
        previous_pilote_id NUMBER := 0;
    BEGIN
        check_nationalite(:new.Nationalite);
    END;
    /

    -- 4. Vérifie l'année d'un championnat de moto.
    CREATE OR REPLACE TRIGGER championnat_check BEFORE INSERT OR UPDATE ON Championnat FOR EACH ROW
    BEGIN
        date_inferior_to_current_time(:new.Annee);
    END;
    /

    -- 5. Vérifie le pays d'un circuit de moto.
    CREATE OR REPLACE TRIGGER circuit_check BEFORE INSERT OR UPDATE ON Circuit FOR EACH ROW
    BEGIN
        check_nationalite(:new.Pays);
    END;
    /

    -- 6. Vérifie la date d'une course de vitesse.
    CREATE OR REPLACE TRIGGER course_vitesse_check BEFORE INSERT OR UPDATE ON Course_vitesse FOR EACH ROW
    BEGIN
        date_inferior_to_current_time(:new.Date_course);
    END;
    /

    -- 7. Vérifie la date d'un contrat et qu'un pilote n'est pas déjà sous contrat valide
    -- lors de la création d'un nouveau contrat.
    CREATE OR REPLACE TRIGGER contrat_check BEFORE INSERT OR UPDATE ON Contrat FOR EACH ROW
    DECLARE
        --  valide BOOLEAN := FALSE;
        --  CURSOR Contrat IS
            --  SELECT Annee_debut, Annee_fin
            --  FROM Contrat C
            --  WHERE Id_pilote = :NEW.Id_pilote;
    BEGIN
        date_inferior_to_current_time(:new.Annee_debut);
        --  Désactivé car cela cause une erreur de table mutante. Je n'ai pas trouvé
        --  de résolution au problème, après avoir essayé de changer la structure de
        --  données ou utiliser une table temporaire...
        --  FOR tuple IN Contrat LOOP
            --  IF ((:NEW.Annee_debut BETWEEN tuple.Annee_debut AND tuple.Annee_fin)
                    --  OR (:NEW.Annee_fin BETWEEN tuple.Annee_debut AND tuple.Annee_fin)) THEN
                --  valide := TRUE;
            --  END IF;
        --  END LOOP;
        --  IF valide = TRUE THEN
            --  RAISE_APPLICATION_ERROR(-20001, 'Insertion cannot be done because the pilot is/was already under a contract during this new contract !');
        --  END IF;
    END;
    /

    -- 8. Vérifie qu'un pilote est bien sous un contrat valide lors de sa participation
    -- à une course et que la moto insérée est bien celle du contrat.
    CREATE OR REPLACE TRIGGER participe_check BEFORE INSERT OR UPDATE ON Participe FOR EACH ROW
    DECLARE
        valide BOOLEAN := FALSE;
        CURSOR Contrat IS
            SELECT Annee_debut, Annee_fin, Moto_modele, Moto_annee
            FROM Contrat C
            WHERE Id_pilote = :NEW.Id_pilote;
    BEGIN
        FOR tuple IN Contrat LOOP
            IF (:NEW.Date_course BETWEEN tuple.Annee_debut AND tuple.Annee_fin) THEN
                IF (:NEW.Modele_moto = tuple.Moto_modele AND :NEW.Annee_moto = tuple.Moto_annee) THEN
                    valide := TRUE;
                END IF;
            END IF;
        END LOOP;
        IF valide = FALSE THEN
            RAISE_APPLICATION_ERROR(-20001, 'Insertion cannot be done because the pilot is/was not under a contract during the race !');
        END IF;
    END;
    /

    -- 9. Vérifie les clés étrangères de la table Course_vitesse.
    CREATE OR REPLACE TRIGGER verif_course_vitesse_cles BEFORE INSERT OR UPDATE ON Course_vitesse FOR EACH ROW
    DECLARE
        nom Championnat.Nom%TYPE;
    BEGIN
        SELECT Nom INTO nom
        FROM Championnat C
        WHERE C.Nom = :NEW.Championnat
            AND C.Annee = :NEW.Annee;

        IF SQL%NOTFOUND THEN
            RAISE_APPLICATION_ERROR(-20001, 'Insertion cannot be done because the championship does not exist');
        END IF;
    END;
    /
    \end{minted}
    \caption{Code PL/SQL programmant les triggers de notre base de données}
    \label{lst.triggers}
\end{code}

\subsection{Méta-données}
\label{sub.metadata}

Les méta-données d'une base de données sont des données stockées à l’intérieur
même de la base décrivant la base de données elle-même, elles ne font donc pas
partie du jeu de données initial. Oracle DBA stocke ces méta-données dans des
tables pré-définies spécialement prévues à cet effet. Nous avons donc écrit une
démonstration de la récupération de ces méta-données afin de pouvoir les
visualiser et avoir des informations sur les contraintes actuellement en vigueur
dans notre base. Cependant, vous pourrez constater dans les commentaires du code
que nous nous sommes confrontés à un problème nous empêchant de mener notre
expérience jusqu’au bout.


\begin{code}
    \begin{minted}[linenos,numbersep=5pt,frame=lines,framesep=2mm,breaklines=true]{SQL}
    -- Liste toutes les contraites de clés étrangères -> clés primaires, trié
    -- par nom de table.
    SELECT C1.TABLE_NAME AS Table_esclave, C2.TABLE_NAME AS Table_maitre, C1.CONSTRAINT_NAME AS Contrainte_id
    FROM USER_CONSTRAINTS C1, USER_CONSTRAINTS C2
    WHERE C1.R_CONSTRAINT_NAME = C2.CONSTRAINT_NAME
        AND C1.CONSTRAINT_TYPE = 'R'
    ORDER BY C1.TABLE_NAME ASC;

    -- Censé lister les contraintes 'CHECK' de la table Participe. Cependant,
    -- la table USER_CONSTRAINTS ne semble pas contenir les CHECK que l'on a
    -- défini... Je ne comprends pas pourquoi.
    SELECT C.TABLE_NAME, C.CONSTRAINT_NAME
    FROM USER_CONSTRAINTS C
    WHERE C.TABLE_NAME = 'Participe'
        AND C.CONSTRAINT_TYPE = 'C'
    ORDER BY C.TABLE_NAME ASC;

    -- Censé lister les triggers de la table Participe. Cependant, la table
    -- ALL_TRIGGERS ne semble pas contenir les triggers que l'on a défini... Je
    -- ne comprends pas pourquoi.
    SELECT T.TABLE_NAME, T.TRIGGER_NAME, T.TRIGGER_TYPE, T.TRIGGERING_EVENT
    FROM ALL_TRIGGERS T
    WHERE T.TABLE_NAME = 'Participe'
    ORDER BY T.TABLE_NAME ASC;
    \end{minted}
    \caption{Code SQL permettant d'afficher les contrainres de notre base}
    \label{lst.metadata}
\end{code}

\begin{code}
    \begin{minted}[linenos,numbersep=5pt,frame=lines,framesep=2mm,breaklines=true]{SQL}
    TABLE_ESCLAVE    TABLE_MAITRE     CONTRAINTE_ID
    --------------------------------- ------------------------------
    CONTRAT          PILOTE           SYS_C0041933
    CONTRAT          TEAM             SYS_C0041935
    CONTRAT          MODELE_MOTO      SYS_C0041934
    COURSE_VITESSE   CIRCUIT          SYS_C0041929
    MODELE_MOTO      MARQUE           SYS_C0041928
    PARTICIPE        PILOTE           SYS_C0041930
    PARTICIPE        COURSE_VITESSE   SYS_C0041931
    PARTICIPE        MODELE_MOTO      SYS_C0041932
    TEAM             MARQUE           SYS_C0041927

    no rows selected

    no rows selected
    \end{minted}
    \caption{Résultat de notre interrogation des méta-données}
    \label{lst.metadata.res}
\end{code}

Nous pouvons observer, sur la première requête qui à bien fonctionné, que les
contraintes d’intégrité entre clés primaires et clés étrangères sont bien
listées : pour le vérifier, il suffit de mettre en corrélation ce résultat avec
le script de création de la base, vu dans la Sous-Section~\ref{sub.scheme}. Nous
avons donc la première colonne avec la table esclave, c’est-à-dire celle qui
possède la clé étrangère, la table maître dans la deuxième colonne, c’est-à-dire
celle qui possède la clé primaire. Enfin, dans la troisième colonne, nous avons
l’identifiant de la contrainte qui est affiché.

\subsection{Analyse des requêtes}
\label{sub.analyze}

Dans cette dernière section, nous avons utilisé l'outil Oracle Explain Plan afin
de pouvoir analyser l’exécution de nos requêtes SQL. Cette analyse permet de
modifier nos requêtes afin qu’elles soient interprétées d’une manière différente
par l’optimiseur de requêtes (Cost Based Optimizer (CBO)) lors de la détection
d’un souci de performance. L’outil s’utilise à travers une clause SQL puis par
interrogation d’une table prévue pour contenir les résultats d’Explain Plan.
Ci-dessous sont listées nos requêtes permettant d’interroger l’outil et récupérer
le résultat :

\begin{code}
    \begin{minted}[linenos,numbersep=5pt,frame=lines,framesep=2mm,breaklines=true]{SQL}
    -- Création des plans d'exécution.

    -- 1. Liste des scores des pilotes au MotoGP de 2016.
    EXPLAIN PLAN FOR
        SELECT Pi.Id, Pi.Numero, Pi.Nom, Pi.Prenom, SUM(Pa.Points_gagnes) AS Nombre_total_de_point
        FROM Participe Pa, Pilote Pi
        WHERE Pa.Id_pilote = Pi.Id
            AND Pa.Championnat LIKE 'MotoGP'
            AND TO_CHAR(Pa.Date_course, 'YYYY') LIKE '2016'
        GROUP BY Pi.Id, Pi.Numero, Pi.Nom, Pi.Prenom
        ORDER BY Nombre_total_de_point DESC;
    SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY('PLAN_TABLE', null, null));

    -- 2. Liste des scores des teams au MotoGP de 2016.
    EXPLAIN PLAN FOR
        SELECT C.Team_nom, SUM(Nombre_total_de_point) AS Nombre_total_de_point
        FROM Contrat C, MotoGP_2016_Score_pilotes S
        WHERE S.Id = C.Id_pilote
            AND TO_DATE(2016, 'YYYY') BETWEEN C.Annee_debut AND C.Annee_fin
        GROUP BY C.Team_nom
        ORDER BY Nombre_total_de_point DESC;
    SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY('PLAN_TABLE', null, null));

    -- 3. Statistiques diverses sur les pilotes du MotoGP.
    EXPLAIN PLAN FOR
        SELECT Pi.Numero, Pi.Nom, Pi.Prenom, Pi.Age, Pi.Nationalite, Pi.Sexe,
            SUM(Pa.Points_gagnes) AS Total_de_points_gagnes,
            MIN(Pa.Classement)    AS Meilleur_classement,
            MAX(Pa.Vitesse_moy)   AS Vitesse_moyenne,
            MIN(Pa.Meilleur_tour) AS Meilleur_tour
        FROM Pilote Pi, Participe Pa
        WHERE Pa.Id_pilote = Pi.Id
            AND Pa.Championnat LIKE 'MotoGP'
        GROUP BY Pi.Numero, Pi.Nom, Pi.Prenom, Pi.Age, Pi.Nationalite, Pi.Sexe;
    SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY('PLAN_TABLE', null, null));
    \end{minted}
    \caption{Code SQL permettant d'utiliser Oracle Explain Plan}
    \label{lst.expplan}
\end{code}

Ci-dessous le résultat de nos requêtes d'interrogation du plan d'exécution :

\begin{code}
    \begin{minted}[linenos,numbersep=5pt,frame=lines,framesep=2mm,breaklines=true]{SQL}
-- 1. Liste des scores des pilotes au MotoGP de 2016.

PLAN_TABLE_OUTPUT
-------------------------------------------------------------------
Plan hash value: 2815421071

-------------------------------------------------------------------
|Id|Operation            |Name     |Rows|Bytes|Cost(%CPU)|Time    |
-------------------------------------------------------------------
| 0|SELECT STATEMENT     |         |  50| 5750|    9 (34)|00:00:01|
| 1| SORT ORDER BY       |         |  50| 5750|    9 (34)|00:00:01|
| 2|  HASH GROUP BY      |         |  50| 5750|    9 (34)|00:00:01|
|*3|   HASH JOIN         |         |  50| 5750|    7 (15)|00:00:01|
| 4|    TABLE ACCESS FULL|PILOTE   |  15|  930|    3  (0)|00:00:01|
|*5|    TABLE ACCESS FULL|PARTICIPE|  50| 2650|    3  (0)|00:00:01|
-------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
3 - access("PA"."ID_PILOTE"="PI"."ID")
5 - filter("PA"."CHAMPIONNAT"='MotoGP' AND
           TO_CHAR(INTERNAL_FUNCTION ("PA"."DATE_COURSE"),'YYYY')='2016')

Note
-----
   - dynamic sampling used for this statement (level=2)

-- 2. Liste des scores des teams au MotoGP de 2016.

PLAN_TABLE_OUTPUT
-----------------------------------------------------------------
Plan hash value: 2104335280

-------------------------------------------------------------------------
|Id|Operation                |Name     |Rows |Bytes|Cost(%CPU)|Time    |
------------------------------------------------------------------------
| 0|SELECT STATEMENT         |         |   40| 1240|  13  (31)|00:00:01|
| 1| SORT ORDER BY           |         |   40| 1240|  13  (31)|00:00:01|
| 2|  HASH GROUP BY          |         |   40| 1240|  13  (31)|00:00:01|
| 3|   VIEW                  |VM_NWVW_1|   40| 1240|  11  (19)|00:00:01|
| 4|    HASH GROUP BY        |         |   40| 7040|  11  (19)|00:00:01|
|*5|     HASH JOIN           |         |   40| 7040|  10  (10)|00:00:01|
|*6|       HASH JOIN         |         |   12| 1476|   7  (15)|00:00:01|
|*7|        TABLE ACCESS FULL|CONTRAT  |   12|  732|   3   (0)|00:00:01|
| 8|        TABLE ACCESS FULL|PILOTE   |   15|  930|   3   (0)|00:00:01|
|*9|       TABLE ACCESS FULL |PARTICIPE|   50| 2650|   3   (0)|00:00:01|
------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   5 - access("PA"."ID_PILOTE"="PI"."ID")
   6 - access("PI"."ID"="C"."ID_PILOTE")
   7 - filter("C"."ANNEE_DEBUT"<=TO_DATE('2016','YYYY') AND
              "C"."ANNEE_FIN">=TO_DATE('2016','YYYY'))
   9 - filter("PA"."CHAMPIONNAT"='MotoGP' AND
              TO_CHAR(INTERNAL_FUNCTION ("PA"."DATE_COURSE"),'YYYY')='2016')

Note
-----
   - dynamic sampling used for this statement (level=2)

-- 3. Statistiques diverses sur les pilotes du MotoGP.

PLAN_TABLE_OUTPUT
-------------------------------------------------------------------
Plan hash value: 2188167404

-------------------------------------------------------------------
|Id|Operation           |Name     |Rows |Bytes|Cost(%CPU)|Time    |
-------------------------------------------------------------------
| 0|SELECT STATEMENT    |         |   50| 8250|   8  (25)|00:00:01|
| 1| HASH GROUP BY      |         |   50| 8250|   8  (25)|00:00:01|
|*2|  HASH JOIN         |         |   50| 8250|   7  (15)|00:00:01|
| 3|   TABLE ACCESS FULL|PILOTE   |   15| 1230|   3   (0)|00:00:01|
| 4|   TABLE ACCESS FULL|PARTICIPE|   50| 4150|   3   (0)|00:00:01|
-------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   2 - access("PA"."ID_PILOTE"="PI"."ID")
   4 - filter("PA"."CHAMPIONNAT"='MotoGP')

Note
-----
   - dynamic sampling used for this statement (level=2)

    \end{minted}
    \caption{Résultat d'Oracle Explain Plan}
    \label{lst.expplan.res}
\end{code}

Nous pouvons ainsi, pour chaque requête, observer toutes les actions effectuées
par le SGBD. Pour chacune de ces actions nous sont affichées des informations telles
que le nombre de colonnes traitées, la taille des données, le temps et la
demande en puissance de traitement estimée pour effectuer l’action. Nous obtenons
aussi des informations sur l’ordre d’exécution des différentes opérations
constituant notre requête. Par exemple, pour effectuer une jointure entre Pilote
et Participe, on observe que notre base demande d’abord un accès complet à ces
deux tables. Ensuite, la restriction effectuée sur le produit cartésien de nos
deux tables est opérée à l’aide d’une comparaison de hashs. Il en va de même
pour le GROUP BY, qui groupe les hashs communs sur une certaine colonne. On
remarque que l'attribut sur lequel porte la jointure est nommé comme étant un
accès, tandis que les attributs sur lesquels portent des restrictions sont
affichés en tant que filtres. Enfin, on observe bien que toutes les opérations
sont estimées être très peu coûteuse, ce qui est évident compte tenu de la
faible taille de notre base de données.

\section{Conclusion}
\label{sec.conc}

Ce projet nous aura beaucoup appris concernant Oracle DBA et PL/SQL. Concernant
Oracle DBA, nous aurons constaté qu’il existe un large écosystème d’outil de
développement autour de ce SGBD, des outils de débogage jusqu’à l’analyse de
performance en passant par des utilitaires facilitant la manipulation des
données. Par rapport à PL/SQL, nous avons pu expérimenter différentes
utilisations du langage, par exemple pour gérer des contraintes avancées ou
encore permettre d’automatiser certaines opérations de gestion des données
nécessitant un programme dynamique. Pour conclure, ce projet aura été une bonne
approche et une introduction intéressante à l’administration de base de données.

\end{document}