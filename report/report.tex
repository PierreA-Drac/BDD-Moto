% Preamble
% =============================================================================

% Class of the document.
\documentclass[12pt,a4paper]{article}
% article : short article.
% report  : mid-length report.
% book    : book or thesis redaction.

% Paragraph skip length (default to 0).
\setlength{\parskip}{1ex}

% Packages
% =============================================================================

% Encoding
% -----------------------------------------------------------------------------

% Babel.
\usepackage[french]{babel}
% FontEnc.
\usepackage[T1]{fontenc}
% InputEnc.
\usepackage[utf8]{inputenc}

% Text
% -----------------------------------------------------------------------------

% Acronym.
\usepackage{acronym}
% CsQuote.
\usepackage[style=french,french=guillemets]{csquotes}
% Enumerate.
\usepackage{enumerate}
% HyperRef.
\usepackage[hyperfootnotes=false,hidelinks]{hyperref}
% URL.
\usepackage{url}

% Algorithms
% -----------------------------------------------------------------------------

% Algorithm2E.
\usepackage[french,onelanguage,linesnumbered,ruled,vlined,commentsnumbered]{algorithm2e}

% Source code
% -----------------------------------------------------------------------------

% Listings.
\usepackage{listings}
% Minted.
\usepackage{minted}
% Caption.
\usepackage{caption}
\newenvironment{code}{\captionsetup{type=listing}}{}

% Figures
% -----------------------------------------------------------------------------

% GraphicX.
\usepackage{graphicx}
% SVG.
\usepackage{svg}
% WrapFig.
\usepackage{wrapfig}

% Charts
% -----------------------------------------------------------------------------

% PGFPLots
\usepackage{pgfplots}
\pgfplotsset{compat=1.16}
\usepgfplotslibrary{units}

% Mathematics
% -----------------------------------------------------------------------------

% AmsFonts.
\usepackage{amsfonts}
% AmsMath.
\usepackage{amsmath}
% AmsText.
\usepackage{amstext}
% AmsThm.
\usepackage{amsthm}
\newtheorem{prr}{Propriété}
\newtheorem{pro}{Proposition}
\newtheorem{thm}{Théorème}
\newtheorem{lem}{Lemme}
% NumPrint.
\usepackage{numprint}

% Physics
% -----------------------------------------------------------------------------

% Physics.
\usepackage{physics}

% Presentation
% -----------------------------------------------------------------------------

% XColor.
\usepackage{xcolor}

% References
% -----------------------------------------------------------------------------

% CleveRef.
\usepackage{cleveref}

% Structure.
% -----------------------------------------------------------------------------

% Geometry.
\usepackage{geometry}
% PDFLScape.
\usepackage{pdflscape}
% MultiCol.
\usepackage{multicol}
% TitleSec.
\usepackage{titlesec}
\newcommand{\sectionbreak}{\clearpage} % Use a page break before new sections.
% VMargin.
\usepackage{vmargin}
% FootMisc.
\usepackage[bottom]{footmisc}

% Symbols
% -----------------------------------------------------------------------------

% SIUnitX.
\usepackage{siunitx}

% Table
% -----------------------------------------------------------------------------

% Array.
\usepackage{array}
% BookTabs.
\usepackage{booktabs}
% CSVSimple.
\usepackage{csvsimple}

% Document
% =============================================================================

\begin{document}

\title{Base de données avec Oracle DBA sur les championnats de moto}
\author{Pierre AYOUB et Maël ROUXEL}

\maketitle

\begin{figure}[b]
    \centering
    \includegraphics[scale=0.3]{figures/isty.jpg}
\end{figure}

\newpage
\begin{abstract}
    
Oracle Database est un système de gestion de bases de données relationnelles
(SGBD) utilisé dans le monde entier. Très répandu en entreprise, tant pour
ses performances que sa fiabilité, nous utilisons ce SGBD afin de créer une
base de données et d’y effectuer des tâches d’administration. Plusieurs
possibilités offertes par Oracle DBA seront explorées dans ce projet.
    
\end{abstract}

\tableofcontents

\section{Introduction}
\label{sec.intro}

Notre projet modélise une base de données concernant les championnats de moto.
L’objectif de cette base est de stocker des informations non pas sur une seule
saison de course, mais sur plusieurs saisons. De plus, on pourra stocker au sein
d’une même base plusieurs championnats différents. Beaucoup d'informations
techniques sont retenues concernant les motos et les résultats des pilotes sur
chaques courses, ce qui permettra d’obtenir des statistiques poussées et
diversifiées. La base de données possède quelques contraintes, listées
ci-dessous (pour les moins évidentes) :

\begin{itemize}
    \item Une saison d'un championnat dure une année.

    \item Par saison, un pilote peut participer à plusieurs championnats.

    \item Pour un championnat donné, un pilote ne peut faire partit que d'une
        team. Dans le cas où le pilote participe à plus d'un championnat sur une
        saison, alors il peut faire partit de plusieurs teams différentes
        concourantes sur différents championnats.

    \item Pour un championnat donné et une team donné, un pilote ne peut
        utiliser qu'une moto. Dans le cas où le pilote participe à plus d'un
        championnat différents sur une saison, alors il peut utiliser plusieurs
        motos différentes sur les différents championnats.

    \item Chaque pilote doit être sous contrat pour pouvoir courir dans un
        championnat. Un contrat est  un CDD liant un pilote, un modèle de moto
        et une team pendant un temps donné (généralement, quelques années).

    \item La participation d’un pilote à un course correspond à une relation
        entre ladite course et le contrat d’un pilote.
\end{itemize}

\section{Mise en place de la base de données}
\label{sec.reference}

Dans cette section, nous vous présenterons la mise en place de la base de
données. Pour la majorité du travail ci-dessous, cela concerne le langage de
requête SQL ou l’utilisation de l’utilitaire de chargement de données Oracle SQL
Loader.

\subsection{Schéma de la base de données}
\label{sub.scheme}

La création du schéma de la base de données consiste à créer les tables en
spécifiant les attributs, leurs types, et leurs contraintes d'intégrités
basiques tel que les clés primaires et étrangères, ainsi que les contraintes
check.

\begin{code}
    \begin{minted}[linenos,numbersep=5pt,frame=lines,framesep=2mm,breaklines=true]{SQL}
    -- Création des tables.

    -- 1. Marques de moto.
    CREATE TABLE Marque
    (
        Nom         VARCHAR(32) NOT NULL,
        Annee       DATE,       -- CHECK with a trigger.
        Nationalite CHAR(2),    -- CHECK with a trigger.
        PRIMARY KEY (Nom)
    );

    -- 2. Teams concourrant aux championnats.
    CREATE TABLE Team
    (
        Nom    VARCHAR(32) NOT NULL,
        Marque VARCHAR(32) NOT NULL,
        PRIMARY KEY (nom)
    );

    -- 3. Modèles de moto.
    CREATE TABLE Modele_moto
    (
        Marque      VARCHAR(32) NOT NULL,
        Nom         VARCHAR(32) NOT NULL,
        Annee       DATE        NOT NULL, -- CHECK with a trigger.
        Cylindree   FLOAT       CHECK (Cylindree > 20 AND Cylindree < 2000),
        Couple      FLOAT       CHECK (Couple > 1     AND Couple < 20),
        Puissance   FLOAT       CHECK (Puissance > 1  AND Puissance < 500),
        Poids       FLOAT       CHECK (Poids > 30     AND Poids < 500),
        Prix        NUMBER(6)   CHECK (Prix > 100 AND Prix < 500000),
        Genre       VARCHAR(40) NOT NULL CHECK (Genre IN ('Sportive', 'Cafe Racer')),
        PRIMARY KEY (nom, annee)
    );

    -- 4. Pilotes appartenant aux teams.
    CREATE TABLE Pilote
    (
        Id          NUMBER(4)   NOT NULL, -- CHECK with a trigger.
        Nom         VARCHAR(32) NOT NULL,
        Prenom      VARCHAR(32) NOT NULL,
        Age         NUMBER(3)   CHECK (Age BETWEEN 10 and 100),
        Nationalite CHAR(2),    -- CHECK with a trigger.
        Sexe        CHAR(1)     CHECK (Sexe IN (NULL, 'H', 'F')),
        Numero      NUMBER(2)   CHECK (Numero BETWEEN 0 and 99),
        PRIMARY KEY (id)
    );

    -- 5. Championnats existants.
    CREATE TABLE Championnat
    (
        Nom         VARCHAR(32) NOT NULL,
        Annee       DATE        NOT NULL,   -- CHECK with a trigger.
        PRIMARY KEY (Nom, Annee)
    );

    -- 6. Circuits sur lesquels les courses se déroulent.
    CREATE TABLE Circuit
    (
        Nom      VARCHAR(32) NOT NULL,
        Pays     CHAR(2)     NOT NULL,  -- CHECK with a trigger.
        Longueur FLOAT       CHECK (Longueur BETWEEN 0.5 AND 20),
        PRIMARY KEY (Nom)
    );

    -- 7. Courses appartenants aux championnats.
    CREATE TABLE Course_vitesse
    (
        Championnat VARCHAR(32) NOT NULL,
        Annee       DATE        NOT NULL,
        Date_course DATE        NOT NULL, -- CHECK with trigger.
        Circuit     VARCHAR(32) NOT NULL,
        Nb_tours    NUMBER(2)   CHECK (Nb_tours BETWEEN 1 AND 30),
        Duree       FLOAT       CHECK (Duree BETWEEN 1 AND 100),
        PRIMARY KEY (Championnat, Date_course)
    );

    -- 8. Participation d'un pilote à une course.
    CREATE TABLE Participe (
        Id_pilote       INT         NOT NULL,
        Championnat     VARCHAR(32) NOT NULL,
        Date_course     DATE        NOT NULL,
        Modele_moto     VARCHAR(32) NOT NULL,
        Annee_moto      DATE        NOT NULL,
        Classement      NUMBER(2)   CHECK (Classement BETWEEN 0 AND 30),
        Points_gagnes   NUMBER(2)   CHECK (Points_gagnes BETWEEN 0 AND 25),
        Vitesse_moy     FLOAT       CHECK (Vitesse_moy BETWEEN 0 AND 300),
        Meilleur_tour   FLOAT       CHECK (Meilleur_tour BETWEEN 0 AND 400),
        PRIMARY KEY (Id_pilote, Championnat, Date_course, Modele_moto, Annee_moto)
    );

    -- 9. Contrats liants un pilote, une équipe et un modèle de moto.
    CREATE TABLE Contrat (
        Id_pilote   NUMBER(4)   NOT NULL,
        Moto_modele VARCHAR(32) NOT NULL,
        Moto_annee  DATE        NOT NULL,
        Team_nom    VARCHAR(32) NOT NULL,
        Annee_debut DATE        NOT NULL,
        Annee_fin   DATE        NOT NULL,
        PRIMARY KEY (Id_pilote, Moto_modele, Moto_annee, Team_nom, Annee_debut)
    );

    -- Configure les clés étrangères.

    ALTER TABLE Team
        ADD FOREIGN KEY (Marque) REFERENCES Marque (Nom);

    ALTER TABLE Modele_moto
        ADD FOREIGN KEY (Marque) REFERENCES Marque (Nom);
        
    -- Désactivé car on utilise un trigger pour ces clés, conformément à la consigne.
    --  ALTER TABLE Course_vitesse
        --  ADD FOREIGN KEY (Championnat, Annee) REFERENCES Championnat (Nom, Annee);
    ALTER TABLE Course_vitesse
        ADD FOREIGN KEY (Circuit) REFERENCES Circuit (Nom);

    ALTER TABLE Participe
        ADD FOREIGN KEY (Id_pilote) REFERENCES Pilote (Id);
    ALTER TABLE Participe
        ADD FOREIGN KEY (Championnat, Date_course) REFERENCES Course_vitesse (Championnat, Date_course);
    ALTER TABLE Participe
        ADD FOREIGN KEY (Modele_moto, Annee_moto) REFERENCES Modele_moto (Nom, Annee);

    ALTER TABLE Contrat
        ADD FOREIGN KEY (Id_pilote) REFERENCES Pilote (Id);
    ALTER TABLE Contrat
        ADD FOREIGN KEY (Moto_modele, Moto_annee) REFERENCES Modele_moto (Nom, Annee);
    ALTER TABLE Contrat
        ADD FOREIGN KEY (Team_nom) REFERENCES Team (Nom);
    \end{minted}
    \caption{Code SQL permettant de mettre en place la base de données}
    \label{lst.create}
\end{code}

\subsection{Jeu de données}
\label{sub.data}

Pour le chargement du jeu de données, nous avons utilisé l'utilitaire spécialisé
Oracle SQL Loader. Du fait que cela ne serait pas pertinent d’inclure
l’intégralité du jeu de données dans le rapport, nous allons uniquement vous
présenter un exemple d’un fichier de données CSV et d’un fichier de contrôle
CTL. Le fichier CSV contient les valeurs des données allant s’intégrer dans les
tables crées précédemment, tandis que le fichier CTL contient des informations
sur la manière dont les données doivent être chargées depuis le fichier CSV. Par
exemple, des précisions sur le type de données, tel que le format de la date.

\begin{code}
    \begin{minted}[linenos,numbersep=5pt,frame=lines,framesep=2mm,breaklines=true]{SQL}
    LOAD DATA
    INFILE './Data/Participe.csv'
    TRUNCATE
    INTO TABLE Participe
    FIELDS TERMINATED BY ';'
    TRAILING NULLCOLS
    (
        Id_pilote,
        Championnat,
        Date_course DATE "YYYY-MM-DD",
        Modele_moto,
        Annee_moto DATE "YYYY",
        Classement,
        Points_gagnes,
        Vitesse_moy,
        Meilleur_tour
    )
    \end{minted}
    \caption{Code SQL Loader permettant de charger des données dans une table}
    \label{lst.loadctl}
\end{code}

\begin{code}
    \begin{minted}[linenos,numbersep=5pt,frame=lines,framesep=2mm,breaklines=true]{SQL}
    Id_pilote;Championnat;Date_course;Modele_moto;Annee_moto; Classement;Points_gagnes;Vitesse_moy;Meilleur_tour
    1;MotoGP;2016-03-20;M1;2016;1;25;167.1;114.543
    0;MotoGP;2016-03-20;Desmosedici GP;2013;2;20;167.0;;
    7;MotoGP;2016-03-20;RC213V;2012;3;16;167.0;;
    4;MotoGP;2016-03-20;M1;2016;4;13;167.0;;
    8;MotoGP;2016-03-20;RC213V;2012;5;11;166.2;;
    5;MotoGP;2016-03-20;GSX-RR;2014;6;10;166.1;;
    11;MotoGP;2016-03-20;RC213V-RS;2015;14;2;164.4;;
    6;MotoGP;2016-03-20;RC213V;2012;0;0;165.0;;
    10;MotoGP;2016-03-20;GSX-RR;2014;18;0;;;
    4;MotoGP;2016-04-24;M1;2016;1;25;157.5;100.090
    [...]
    13;Superbike;2015-02-22;GSX-R1000;2014;9;7;;;92.690
    14;Superbike;2015-02-22;ZX-10R;2015;6;10;;;92.016
    \end{minted}
    \caption{Fichier CSV contenant des données à charger (extrait)}
    \label{lst.loadcsv}
\end{code}

De plus, nous avons utilisé une séquence (initialisée à partir du nombre maximum
déjà inséré dans la base de données) afin de générer des entiers naturels
consécutifs en tant qu'identifiant pour nos pilotes :

\begin{code}
    \begin{minted}[linenos,numbersep=5pt,frame=lines,framesep=2mm,breaklines=true]{SQL}
    -- Création des séquences.

    -- 1. Création et configuration de la séquence des IDs des pilotes.
    DECLARE
        max_pilote_id NUMBER := 0;
    BEGIN
        SELECT MAX(Id) INTO max_pilote_id FROM Pilote;
        EXECUTE IMMEDIATE 'CREATE SEQUENCE PiloteID INCREMENT BY 1 START WITH ' || (max_pilote_id + 1);
    END; 
    /
    CREATE OR REPLACE TRIGGER pilote_set_id BEFORE INSERT ON Pilote FOR EACH ROW
    DECLARE
    BEGIN
        :NEW.Id := PiloteID.NextVal;
    END;
    /
    \end{minted}
    \caption{Code SQL permettant d'initialiser et d'utiliser une séquence}
    \label{lst.seq}
\end{code}

\subsection{Manipulation des données par requêtes SQL}
\label{sub.req}

TODO Maël

\subsection{Vues}
\label{sub.views}

Notre base de données contient quelques vues permettant de visualiser des scores
et des statistiques calculés à partir de notre jeu de données. De tels vues se
destinerait à être inclus dans un site ou service web permettant de consulter
des statistiques sur les championnats de moto, avec des paramètres dynamiques
tel que, par exemple, l'année des scores pour ledit championnat.

\begin{code}
    \begin{minted}[linenos,numbersep=5pt,frame=lines,framesep=2mm,breaklines=true]{SQL}
    -- Création des vues.

    -- 1. Liste des scores des pilotes au MotoGP de 2016.
    CREATE VIEW MotoGP_2016_Score_pilotes AS
        SELECT Pi.Id, Pi.Numero, Pi.Nom, Pi.Prenom, SUM(Pa.Points_gagnes) AS Nombre_total_de_point
        FROM Participe Pa, Pilote Pi
        WHERE Pa.Id_pilote = Pi.Id
            AND Pa.Championnat LIKE 'MotoGP'
            AND TO_CHAR(Pa.Date_course, 'YYYY') LIKE '2016'
        GROUP BY Pi.Id, Pi.Numero, Pi.Nom, Pi.Prenom
        ORDER BY Nombre_total_de_point DESC
        WITH READ ONLY;
    GRANT SELECT ON MotoGP_2016_Score_pilotes to PUBLIC;
        
    -- 2. Liste des scores des teams au MotoGP de 2016.
    CREATE VIEW MotoGP_2016_Score_teams AS
        SELECT C.Team_nom, SUM(Nombre_total_de_point) AS Nombre_total_de_point
        FROM Contrat C, MotoGP_2016_Score_pilotes S
        WHERE S.Id = C.Id_pilote
            AND TO_DATE(2016, 'YYYY') BETWEEN C.Annee_debut AND C.Annee_fin
        GROUP BY C.Team_nom
        ORDER BY Nombre_total_de_point DESC
        WITH READ ONLY;
    GRANT SELECT ON MotoGP_2016_Score_teams to PUBLIC;

    -- 3. Liste des scores des constructeurs au MotoGP de 2016.
    CREATE VIEW MotoGP_2016_Score_construc AS
        SELECT T.Marque, SUM(Nombre_total_de_point) AS Nombre_total_de_point
        FROM Team T, MotoGP_2016_Score_teams S
        WHERE T.Nom = S.Team_nom
        GROUP BY T.Marque
        ORDER BY Nombre_total_de_point DESC
        WITH READ ONLY;
    GRANT SELECT ON MotoGP_2016_Score_construc to PUBLIC;

    -- 4. Statistiques diverses sur les pilotes du MotoGP.
    CREATE VIEW MotoGP_Pilote_stat AS
        SELECT Pi.Numero, Pi.Nom, Pi.Prenom, Pi.Age, Pi.Nationalite, Pi.Sexe,
            SUM(Pa.Points_gagnes) AS Total_de_points_gagnes,
            MIN(Pa.Classement)    AS Meilleur_classement,
            MAX(Pa.Vitesse_moy)   AS Vitesse_moyenne,
            MIN(Pa.Meilleur_tour) AS Meilleur_tour
        FROM Pilote Pi, Participe Pa
        WHERE Pa.Id_pilote = Pi.Id
            AND Pa.Championnat LIKE 'MotoGP'
        GROUP BY Pi.Numero, Pi.Nom, Pi.Prenom, Pi.Age, Pi.Nationalite, Pi.Sexe
        WITH READ ONLY;
    GRANT SELECT ON MotoGP_Pilote_stat to PUBLIC;

    -- 5. Nombre de victoire des pilotes au MotoGP.
    CREATE VIEW MotoGP_Pilote_win AS
        SELECT Pi.Numero, Pi.Nom, Pi.Prenom, COUNT(*) AS Nombre_de_victoire
        FROM Pilote Pi, Participe Pa
        WHERE Pa.Id_pilote = Pi.Id
            AND Pa.Championnat LIKE 'MotoGP'
            AND Pa.Classement = 1
        GROUP BY Pi.Numero, Pi.Nom, Pi.Prenom
        ORDER BY Nombre_de_victoire DESC
        WITH READ ONLY;
    GRANT SELECT ON MotoGP_Pilote_win to PUBLIC;
    \end{minted}
    \caption{Code SQL permettant de créer les vues de la base de données}
    \label{lst.create}
\end{code}

\section{SQL Avancé}
\label{sec.reference}

Cette deuxième section nous amènera à utiliser des fonctionnalités avancées
d’Oracle DBA et de PL/SQL. Nous étudierons tout d’abord quelques triggers, puis
opérerons à la récupération de méta-données afin d’obtenir des informations sur
notre base de données, enfin nous effectuerons une rapide analyse de requête
SQL.

\subsection{Triggers}
\label{sub.trig}

Les triggers sont utilisés, dans notre projet, afin d'implémenter des
contraintes d'intégrités. Pour la plupart des triggers, ces contraintes ne
peuvent être exprimées avec des clauses CHECK du fait qu’il faut  récupérer les
valeurs de certains tuples d’une autre table et qu’il est nécessaire d’avoir un
contrôle de flux en fonction des résultats. Pour un des triggers ci-dessous,
nous avons ré-implémenté le fonctionnement des clés étrangères, comme demandé
dans le sujet.

\begin{code}
    \begin{minted}[linenos,numbersep=5pt,frame=lines,framesep=2mm,breaklines=true]{SQL}
    -- Création des procédures.

    -- 1. Vérifie qu'une date est inférieure à la date du jour. Nécéssite un
    -- trigger/une procédure pour utiliser SYSDATE.
    CREATE OR REPLACE PROCEDURE date_inferior_to_current_time (new_date IN DATE) IS
    BEGIN
        IF new_date > SYSDATE THEN
            RAISE_APPLICATION_ERROR(-20001, 'Insertion cannot be done because the date is greater than today !');
        END IF;
    END;
    /

    -- 2. Vérifie qu'une nationalité est correct. On pourrait utiliser un CHECK, mais
    -- il faudrait coper-coller les valeurs de nationalités à la main, alors que
    -- l'on peux les regrouper dans une procédure.
    CREATE OR REPLACE PROCEDURE check_nationalite (nat IN CHAR) IS
    BEGIN
        IF (nat NOT IN ('FR', 'GB', 'US', 'IT', 'ES', 'JP', 'CH', 'DE', 'AU', 'QT', 'PB')) THEN
            RAISE_APPLICATION_ERROR(-20001, 'Insertion cannot be done because the nationality is incorrect !');
        END IF;
    END;
    /

    -- Création des triggers.

    -- 1. Vérifie l'année de création et la nationalité d'une marque.
    CREATE OR REPLACE TRIGGER marque_check BEFORE INSERT OR UPDATE ON Marque FOR EACH ROW
    BEGIN
        date_inferior_to_current_time(:new.Annee);
        check_nationalite(:new.Nationalite);
    END;
    /

    -- 2. Vérifie l'année d'un modèle de moto.
    CREATE OR REPLACE TRIGGER modele_moto_check BEFORE INSERT OR UPDATE ON Modele_moto FOR EACH ROW
    BEGIN
        date_inferior_to_current_time(:new.Annee);
    END;
    /

    -- 3. Vérifie la nationalité d'un pilote.
    CREATE OR REPLACE TRIGGER pilote_check BEFORE INSERT OR UPDATE ON Pilote FOR EACH ROW
    DECLARE
        previous_pilote_id NUMBER := 0;
    BEGIN
        check_nationalite(:new.Nationalite);
    END;
    /

    -- 4. Vérifie l'année d'un championnat de moto.
    CREATE OR REPLACE TRIGGER championnat_check BEFORE INSERT OR UPDATE ON Championnat FOR EACH ROW
    BEGIN
        date_inferior_to_current_time(:new.Annee);
    END;
    /

    -- 5. Vérifie le pays d'un circuit de moto.
    CREATE OR REPLACE TRIGGER circuit_check BEFORE INSERT OR UPDATE ON Circuit FOR EACH ROW
    BEGIN
        check_nationalite(:new.Pays);
    END;
    /

    -- 6. Vérifie la date d'une course de vitesse.
    CREATE OR REPLACE TRIGGER course_vitesse_check BEFORE INSERT OR UPDATE ON Course_vitesse FOR EACH ROW
    BEGIN
        date_inferior_to_current_time(:new.Date_course);
    END;
    /

    -- 7. Vérifie la date d'un contrat et qu'un pilote n'est pas déjà sous contrat valide
    -- lors de la création d'un nouveau contrat.
    CREATE OR REPLACE TRIGGER contrat_check BEFORE INSERT OR UPDATE ON Contrat FOR EACH ROW
    DECLARE
        --  valide BOOLEAN := FALSE;
        --  CURSOR Contrat IS
            --  SELECT Annee_debut, Annee_fin
            --  FROM Contrat C
            --  WHERE Id_pilote = :NEW.Id_pilote;
    BEGIN
        date_inferior_to_current_time(:new.Annee_debut);
        --  Désactivé car cela cause une erreur de table mutante. Je n'ai pas trouvé
        --  de résolution au problème, après avoir essayé de changer la structure de
        --  données ou utiliser une table temporaire...
        --  FOR tuple IN Contrat LOOP
            --  IF ((:NEW.Annee_debut BETWEEN tuple.Annee_debut AND tuple.Annee_fin)
                    --  OR (:NEW.Annee_fin BETWEEN tuple.Annee_debut AND tuple.Annee_fin)) THEN
                --  valide := TRUE;
            --  END IF;
        --  END LOOP;
        --  IF valide = TRUE THEN
            --  RAISE_APPLICATION_ERROR(-20001, 'Insertion cannot be done because the pilot is/was already under a contract during this new contract !');
        --  END IF;
    END;
    /

    -- 8. Vérifie qu'un pilote est bien sous un contrat valide lors de sa participation
    -- à une course et que la moto insérée est bien celle du contrat.
    CREATE OR REPLACE TRIGGER participe_check BEFORE INSERT OR UPDATE ON Participe FOR EACH ROW
    DECLARE
        valide BOOLEAN := FALSE;
        CURSOR Contrat IS
            SELECT Annee_debut, Annee_fin, Moto_modele, Moto_annee
            FROM Contrat C
            WHERE Id_pilote = :NEW.Id_pilote;
    BEGIN
        FOR tuple IN Contrat LOOP
            IF (:NEW.Date_course BETWEEN tuple.Annee_debut AND tuple.Annee_fin) THEN
                IF (:NEW.Modele_moto = tuple.Moto_modele AND :NEW.Annee_moto = tuple.Moto_annee) THEN
                    valide := TRUE;
                END IF;
            END IF;
        END LOOP;
        IF valide = FALSE THEN
            RAISE_APPLICATION_ERROR(-20001, 'Insertion cannot be done because the pilot is/was not under a contract during the race !');
        END IF;
    END;
    /

    -- 9. Vérifie les clés étrangères de la table Course_vitesse.
    CREATE OR REPLACE TRIGGER verif_course_vitesse_cles BEFORE INSERT OR UPDATE ON Course_vitesse FOR EACH ROW
    DECLARE
        nom Championnat.Nom%TYPE;
    BEGIN
        SELECT Nom INTO nom
        FROM Championnat C
        WHERE C.Nom = :NEW.Championnat
            AND C.Annee = :NEW.Annee;

        IF SQL%NOTFOUND THEN
            RAISE_APPLICATION_ERROR(-20001, 'Insertion cannot be done because the championship does not exist');
        END IF;
    END;
    /
    \end{minted}
    \caption{Code PL/SQL programmant les triggers de notre base de données}
    \label{lst.triggers}
\end{code}

\subsection{Méta-données}
\label{sub.metadata}

Les méta-données d'une base de données sont des données stockées à l’intérieur
même de la base décrivant la base de données elle-même, elles ne font donc pas
partie du jeu de données initial. Oracle DBA stock ces méta-données dans des
tables pré-définies spécialement prévues à cet effet. Nous avons donc écris une
démonstration de la récupération de ces méta-données afin de pouvoir les
visualiser et avoir des informations sur les contraintes actuellement en vigueur
dans notre base. Cependant, vous pourrez constater dans les commentaires du code
que nous nous sommes confrontés à un problème nous empêchant de mener notre
expérience jusqu’au bout.


\begin{code}
    \begin{minted}[linenos,numbersep=5pt,frame=lines,framesep=2mm,breaklines=true]{SQL}
    -- Liste toutes les contraites de clés étrangères -> clés primaires, trié
    -- par nom de table.
    SELECT C1.TABLE_NAME AS Table_esclave, C2.TABLE_NAME AS Table_maitre, C1.CONSTRAINT_NAME AS Contrainte_id
    FROM USER_CONSTRAINTS C1, USER_CONSTRAINTS C2
    WHERE C1.R_CONSTRAINT_NAME = C2.CONSTRAINT_NAME
        AND C1.CONSTRAINT_TYPE = 'R'
    ORDER BY C1.TABLE_NAME ASC;

    -- Censé lister les contraintes 'CHECK' de la table Participe. Cependant,
    -- la table USER_CONSTRAINTS ne semble pas contenir les CHECK que l'on a
    -- défini... Je ne comprends pas pourquoi.
    SELECT C.TABLE_NAME, C.CONSTRAINT_NAME
    FROM USER_CONSTRAINTS C
    WHERE C.TABLE_NAME = 'Participe'
        AND C.CONSTRAINT_TYPE = 'C'
    ORDER BY C.TABLE_NAME ASC;

    -- Censé lister les triggers de la table Participe. Cependant, la table
    -- ALL_TRIGGERS ne semble pas contenir les triggers que l'on a défini... Je
    -- ne comprends pas pourquoi.
    SELECT T.TABLE_NAME, T.TRIGGER_NAME, T.TRIGGER_TYPE, T.TRIGGERING_EVENT
    FROM ALL_TRIGGERS T
    WHERE T.TABLE_NAME = 'Participe'
    ORDER BY T.TABLE_NAME ASC;
    \end{minted}
    \caption{Code SQL permettant d'afficher les contrainres de notre base}
    \label{lst.metadata}
\end{code}

\begin{code}
    \begin{minted}[linenos,numbersep=5pt,frame=lines,framesep=2mm,breaklines=true]{SQL}
    TABLE_ESCLAVE    TABLE_MAITRE     CONTRAINTE_ID
    --------------------------------- ------------------------------
    CONTRAT          PILOTE           SYS_C0041933
    CONTRAT          TEAM             SYS_C0041935
    CONTRAT          MODELE_MOTO      SYS_C0041934
    COURSE_VITESSE   CIRCUIT          SYS_C0041929
    MODELE_MOTO      MARQUE           SYS_C0041928
    PARTICIPE        PILOTE           SYS_C0041930
    PARTICIPE        COURSE_VITESSE   SYS_C0041931
    PARTICIPE        MODELE_MOTO      SYS_C0041932
    TEAM             MARQUE           SYS_C0041927

    no rows selected
    
    no rows selected
    \end{minted}
    \caption{Résultat de notre interrogation des méta-données}
    \label{lst.metadata.res}
\end{code}

Nous pouvons observer, sur la première requête qui à bien fonctionné, que les
contraintes d’intégrités entre clés primaires et clés étrangères sont bien
listées : pour le vérifier, il suffit de mettre en corrélation ce résultat avec
le script de création de la base, vu dans la Sous-Section~\ref{sub.scheme}. Nous
avons donc la première colonne avec la table esclave, c’est-à-dire celle qui
possède la clé étrangère, la table maître dans la deuxième colonne, c’est-à-dire
celle qui possède la clé primaire. Enfin, dans la troisième colonne, nous avons
l’identifiant de la contrainte qui est affiché.

\subsection{Analyse des requêtes}
\label{sub.analyze}

Dans cette dernière section, nous avons utilisé l'outil Oracle Explain Plan afin
de pouvoir analyser l’exécution de nos requêtes SQL. Cette analyse permet de
modifier nos requêtes afin qu’elles soient interprétées d’une manière différente
par l’optimiseur de requête (Cost Based Optimizer (CBO)) lors de la détection
d’un soucis de performance. L’outil s’utilise à travers une clause SQL puis par
interrogation d’une table prévue pour contenir les résultats d’Explain Plan.
Ci-dessous sont listés nos requêtes permettant d’interroger l’outil et récupérer
le résultat :

\begin{code}
    \begin{minted}[linenos,numbersep=5pt,frame=lines,framesep=2mm,breaklines=true]{SQL}
    -- Création des plans d'exécution.

    -- 1. Liste des scores des pilotes au MotoGP de 2016.
    EXPLAIN PLAN FOR
        SELECT Pi.Id, Pi.Numero, Pi.Nom, Pi.Prenom, SUM(Pa.Points_gagnes) AS Nombre_total_de_point
        FROM Participe Pa, Pilote Pi
        WHERE Pa.Id_pilote = Pi.Id
            AND Pa.Championnat LIKE 'MotoGP'
            AND TO_CHAR(Pa.Date_course, 'YYYY') LIKE '2016'
        GROUP BY Pi.Id, Pi.Numero, Pi.Nom, Pi.Prenom
        ORDER BY Nombre_total_de_point DESC;
    SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY('PLAN_TABLE', null, null));

    -- 2. Liste des scores des teams au MotoGP de 2016.
    EXPLAIN PLAN FOR
        SELECT C.Team_nom, SUM(Nombre_total_de_point) AS Nombre_total_de_point
        FROM Contrat C, MotoGP_2016_Score_pilotes S
        WHERE S.Id = C.Id_pilote
            AND TO_DATE(2016, 'YYYY') BETWEEN C.Annee_debut AND C.Annee_fin
        GROUP BY C.Team_nom
        ORDER BY Nombre_total_de_point DESC;
    SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY('PLAN_TABLE', null, null));

    -- 3. Statistiques diverses sur les pilotes du MotoGP.
    EXPLAIN PLAN FOR
        SELECT Pi.Numero, Pi.Nom, Pi.Prenom, Pi.Age, Pi.Nationalite, Pi.Sexe,
            SUM(Pa.Points_gagnes) AS Total_de_points_gagnes,
            MIN(Pa.Classement)    AS Meilleur_classement,
            MAX(Pa.Vitesse_moy)   AS Vitesse_moyenne,
            MIN(Pa.Meilleur_tour) AS Meilleur_tour
        FROM Pilote Pi, Participe Pa
        WHERE Pa.Id_pilote = Pi.Id
            AND Pa.Championnat LIKE 'MotoGP'
        GROUP BY Pi.Numero, Pi.Nom, Pi.Prenom, Pi.Age, Pi.Nationalite, Pi.Sexe;
    SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY('PLAN_TABLE', null, null));
    \end{minted}
    \caption{Code SQL permettant d'utiliser Oracle Explain Plan}
    \label{lst.expplan}
\end{code}

Ci-dessous le résultat de nos requêtes d'interrogation du plan d'exécution :

\begin{code}
    \begin{minted}[linenos,numbersep=5pt,frame=lines,framesep=2mm,breaklines=true]{SQL}
-- 1. Liste des scores des pilotes au MotoGP de 2016.

PLAN_TABLE_OUTPUT
-------------------------------------------------------------------
Plan hash value: 2815421071

-------------------------------------------------------------------
|Id|Operation            |Name     |Rows|Bytes|Cost(%CPU)|Time    |
-------------------------------------------------------------------
| 0|SELECT STATEMENT     |         |  50| 5750|    9 (34)|00:00:01|
| 1| SORT ORDER BY       |         |  50| 5750|    9 (34)|00:00:01|
| 2|  HASH GROUP BY      |         |  50| 5750|    9 (34)|00:00:01|
|*3|   HASH JOIN         |         |  50| 5750|    7 (15)|00:00:01|
| 4|    TABLE ACCESS FULL|PILOTE   |  15|  930|    3  (0)|00:00:01|
|*5|    TABLE ACCESS FULL|PARTICIPE|  50| 2650|    3  (0)|00:00:01|
-------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------
3 - access("PA"."ID_PILOTE"="PI"."ID")
5 - filter("PA"."CHAMPIONNAT"='MotoGP' AND
           TO_CHAR(INTERNAL_FUNCTION ("PA"."DATE_COURSE"),'YYYY')='2016')

Note
-----
   - dynamic sampling used for this statement (level=2)

-- 2. Liste des scores des teams au MotoGP de 2016.

PLAN_TABLE_OUTPUT
-----------------------------------------------------------------
Plan hash value: 2104335280

-------------------------------------------------------------------------
|Id|Operation                |Name     |Rows |Bytes|Cost(%CPU)|Time    |
------------------------------------------------------------------------
| 0|SELECT STATEMENT         |         |   40| 1240|  13  (31)|00:00:01|
| 1| SORT ORDER BY           |         |   40| 1240|  13  (31)|00:00:01|
| 2|  HASH GROUP BY          |         |   40| 1240|  13  (31)|00:00:01|
| 3|   VIEW                  |VM_NWVW_1|   40| 1240|  11  (19)|00:00:01|
| 4|    HASH GROUP BY        |         |   40| 7040|  11  (19)|00:00:01|
|*5|     HASH JOIN           |         |   40| 7040|  10  (10)|00:00:01|
|*6|       HASH JOIN         |         |   12| 1476|   7  (15)|00:00:01|
|*7|        TABLE ACCESS FULL|CONTRAT  |   12|  732|   3   (0)|00:00:01|
| 8|        TABLE ACCESS FULL|PILOTE   |   15|  930|   3   (0)|00:00:01|
|*9|       TABLE ACCESS FULL |PARTICIPE|   50| 2650|   3   (0)|00:00:01|
------------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   5 - access("PA"."ID_PILOTE"="PI"."ID")
   6 - access("PI"."ID"="C"."ID_PILOTE")
   7 - filter("C"."ANNEE_DEBUT"<=TO_DATE('2016','YYYY') AND
              "C"."ANNEE_FIN">=TO_DATE('2016','YYYY'))
   9 - filter("PA"."CHAMPIONNAT"='MotoGP' AND
              TO_CHAR(INTERNAL_FUNCTION ("PA"."DATE_COURSE"),'YYYY')='2016')

Note
-----
   - dynamic sampling used for this statement (level=2)
   
-- 3. Statistiques diverses sur les pilotes du MotoGP.

PLAN_TABLE_OUTPUT
-------------------------------------------------------------------
Plan hash value: 2188167404

-------------------------------------------------------------------
|Id|Operation           |Name     |Rows |Bytes|Cost(%CPU)|Time    |
-------------------------------------------------------------------
| 0|SELECT STATEMENT    |         |   50| 8250|   8  (25)|00:00:01|
| 1| HASH GROUP BY      |         |   50| 8250|   8  (25)|00:00:01|
|*2|  HASH JOIN         |         |   50| 8250|   7  (15)|00:00:01|
| 3|   TABLE ACCESS FULL|PILOTE   |   15| 1230|   3   (0)|00:00:01|
| 4|   TABLE ACCESS FULL|PARTICIPE|   50| 4150|   3   (0)|00:00:01|
-------------------------------------------------------------------

Predicate Information (identified by operation id):
---------------------------------------------------

   2 - access("PA"."ID_PILOTE"="PI"."ID")
   4 - filter("PA"."CHAMPIONNAT"='MotoGP')

Note
-----
   - dynamic sampling used for this statement (level=2)

    \end{minted}
    \caption{Résultat d'Oracle Explain Plan}
    \label{lst.expplan.res}
\end{code}

Nous pouvons ainsi, pour chaque requête, observer toutes les actions effectuées
par le SGBD. Pour chacune de ses actions nous sont affichés des informations tel
que le nombre de colonnes traitées, la taille des données, le temps et la
demande en puissance de traitement estimé pour effectuer l’action. Nous obtenons
aussi des informations sur l’ordre d’exécution des différentes opérations
constituant notre requête. Par exemple, pour effectuer une jointure entre Pilote
et Participe, on observe que notre base demande d’abord un accès complet à ces
deux tables. Ensuite, la restriction effectuée sur le produit cartésien de nos
deux tables est opérée à l’aide d’une comparaison de hashs. Il en va de même
pour le GROUP BY, qui groupe les hashs communs sur une certaine colonne. On
remarque que l'attribut sur lequel porte la jointure est nommé comme étant un
accès, tandis que les attributs sur lesquels portent des restrictions sont
affichés en tant que filtres. Enfin, on observe bien que toutes les opérations
sont estimées être très peu coûteuse, ce qui est évident compte tenu de la
faible taille de notre base de données.

\section{Conclusion}
\label{sec.conc}

Ce projet nous aura beaucoup appris concernant Oracle DBA et PL/SQL. Concernant
Oracle DBA, nous aurons constaté qu’il existe un large écosystème d’outil de
développement autour de ce SGBD, des outils de débogage jusqu’à l’analyse de
performance en passant par des utilitaires facilitant la manipulation des
données. Par rapport à PL/SQL, nous avons pu expérimenter différentes
utilisations du langage, par exemple pour gérer des contraintes avancées ou
encore permettre d’automatiser certaines opérations de gestion des données
nécessitant un programme dynamique. Pour conclure, ce projet aura été une bonne
approche et une introduction intéressante à l’administration de base de données.

\end{document}
